# Python学习

## 第一章、介绍

### 程序设计语言的分类

#### 1、程序设计语言包括

1. 机器语言（二进制语言）
2. 汇编语言
3. 高级语言（Python，Java）

*注：高级语言接近我们使用的自然语言<br>不使用自然语言的原因是有歧义*

#### 2、编译与解释

- **编译型**

采用这种编译型的编程语言就叫**静态语言**—（Java）

<img src="https://bucket-wl.oss-cn-guangzhou.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-02-05%20220439.png" style="zoom:35%;" />

==优点：目标代码的执行速度更快，不需要编译器就可以直接运行==
==缺点：是不方便修改，要先修改源代码再重新编译执行==

- **解释型**

**脚本语言**—（Python、JavaScript、PHP）

<img src="https://bucket-wl.oss-cn-guangzhou.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-02-05%20220516.png" style="zoom:80%;" />

==优点：保留了源代码程序的纠错和维护很方便，可移植性更好==
==缺点：要始终保持有源代码==

------

###  Python语言的简介

#### 1、特点

- 语法简洁
- 平台无关
- 粘性拓展
- 开源理念
- 灵活通用
- 强制可读
- 支持中文
- 模式多样
- 类库丰富

#### 2、应用领域

- **Web开发**
	有着Django、Flask、Tornado等众多框架

- **数据分析与科学计算**
	有众多第三方库支持，如Numpy、Pandas、Matplotlib等
- **人工智能和机器学习**
	Python中的第三方库TensorFlow、Keras、PyTorch等可以快速的实现模型构建、训练和部署
- **自动化测试和运维**
	第三方库Selenium在自动化测试和运维领域发挥着举足轻重的作用，自动化测试已经成为测试工程师必备的技能之一
- **网络爬虫**
	爬虫在互联网中发挥非常重要的作用，他以速度快的特点，可以在互联网上爬取大量的数据，这些数据正是大数据和数据挖掘为进行后续操作的基础
- **游戏开发**
	例如《文明6》就是Python语言编写的

---

### IPO编程方法

<img src="https://bucket-wl.oss-cn-guangzhou.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-02-06%20002132.png" style="zoom:80%;" />

---

## 第二章、Python基础

### 一、输出函数print

#### 1、语法结构：

​	print(输出内容)

#### 2、内容：

1. 数字
2. 变量
3. 字符串（用引号引起来，*可用单引号、双引号、三引号*）
4. 包含运算的表达式（直接输出结果）

`````python
print(90)
print(a)
print('你好')
print("你好")
print('''你好''')
print("""你好""")
print(a+b)
`````

5. 不换行输出多个内容中间用逗号隔开（ ==**，**== ）

​	 `print(a,b,'你好'，a*b)`

6. 通过ASCII码输出字符

  `print(chr(97))`

7. 中文编码Unicode码（范围从U4E00到U9FA5）

```python
print(ord('北'))
print(ord('京'))
print(chr(21271),chr(20140))
```

#### 3、把数据输出到文件中

内置函数：**open**

`````python
fp = open('note.tet', 'w')  # 打开文件 w-->write
print('北京欢迎你', file=fp)  # 将“北京欢迎你”写入到note.tet文件
fp.close()  # 关闭文件
`````

#### 4、修改输出结构

**print()函数完整的语法格式：**

​	print(value,…,sep=‘ ’,end=‘\n’,file=None)

>  因此每次输出结束默认换行(\n)
>
> ```python
> print('北京',end='')
> print('欢迎你',end='>-<')
> ```
>
> 修改结束符，使输出结果为（北京欢迎你>-<）

> 同理每次输出间隔默认空格( )
>
> ```python
> print('北京'+'欢迎你')
> ```
>
> 修改间隔符，用加号使输出结果为（北京欢迎你）
> *注：只能是字符串与字符串连*

---

### 二、输入函数input

#### 1、语法结构

x=input(‘提示文字’)

#### 2、格式

默认接受为字符串
要接受整数需要用int()

```python
name=input('请输入你的名字：')
age=int(input('请输入你的年龄：'))
print('你的姓名是：'+name,'你的年龄是：',age)
```



---

### 三、Python中的注释

作用：提高可读性

#### 1、单行注释

```python
#注释
```

符号：#

#### 2、多行注释

```python
'''
放在这中间的就是多行注释
可以换行
'''

"""
放在这中间也是一样的
"""
```

符号：三个单引号（‘’‘）或三个双引号（“”“）

#### 3、中文声明注释*

- 一定要写在第一行

```python
# coding=utf-8
```

<img src="https://bucket-wl.oss-cn-guangzhou.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-02-06%20221612.png" style="zoom:50%;" />

---

### 四、代码缩进

<img src="https://bucket-wl.oss-cn-guangzhou.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-02-06%20222021.png" style="zoom:45%;" />

```python
#一般代码不需要缩进
print('你好')
print('hello')
#类的定义
class Student:
  pass
#函数的定义
def fun():
  pass
```

---

## 第三章、数据类型和运算符

### 一、保留字与标识符

#### 1、保留字

不可用保留字作为变量、函数、类、模块和其他对象的名称使用

<img src="https://bucket-wl.oss-cn-guangzhou.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-02-07%20002846.png" style="zoom:70%;" />

```python
import keyword #导入
print(keyword.kwlist) #打印保留字列表
print(len(keyword.kwlist))#获取保留字个数
```

*注：保留字严格区分大小写*

#### 2、标识符

**命名规则（必须遵守）：**

- 可以是字符（英文、中文）、下划线（-）和数字，但是第一个字符不能是数字
- 不能使用Python中的保留字
- 严格区分大小写
- 以下划线开头的标识符具有特殊意义，一般应避免使用相似的标识符
- 允许使用中文作为标识符，但是不建议使用

**命名规范（建议遵守）：**

- 模块名尽量短小，并且全部使用小写字母，可以用下划线分割多个字母
	例如：grame_main
- 包名尽量短小，并且全部使用小写字母，不推荐用下划线
	例如：com.wlpython，不推荐用com_wlpython
- 类名采用单词首字母大写形式（Pascal风格）
	例如：MyClass
- 模块内部的类采用”_“ + Pascal 风格的类名组成
	例如：在MyClass中的内部类 _InnerMyClass
- 函数、类的属性和方法的命名，全部使用小写字母，多个字母之间用下划线分割
- 常量命名时采用全部大写字母，可以使用下划线
- 使用单下划线“_”开头的模块变量或函数是受保护的，在使用 “from xxx import *” 语句从模块中导入时，这些模块变量或函数不能被导入
- 使用双下划线 “__” 开头的实例变量或方法是类私有的
- 以双下划线开头和结尾的是Python的专用标识
	例如\__init__()表示初始化函数

### 二、变量与常量

#### 1、变量的语法结构

变量名=value
*例：luck_number=8*

==Python是种动态类型的语言——变量的类型可以随时变化==
可以使用type()函数查看数据类型

```
luck_number=7
print('luck_number的数据类型是：',type(luck_number))
```

==Python允许多个变量指向同一个值==
用id()函数查看对象的内存地址

```python
no=number=1024
print(no,number)
print(id(no))
print(id(number))
```

#### 2、常量的定义

命名全部采用大写字母加下划线的形式

### 三、数据类型

#### 1、数值类型（不可变数据类型）

1. 整数类型
	表示没有小数部分的数值，包括正整数、负整数和0
	<img src="https://bucket-wl.oss-cn-guangzhou.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-02-08%20171125.png" style="zoom:60%;" />

2. 浮点数类型

	> 表示带有小数点的数值，由整数部分和小数部分组成
	> *注：两个浮点类型的数在进行运算时，有一定的概率运算结果后增加一些“**不确定的**”尾数*
	>
	> `print(0.1+0.2)#不确定的尾数问题输出“0.30000000000000004”`
	> 	解决方法用round()函数保留几位小数
	>
	> `print(round(0.1+0.2,1))#保留一位小数`

3. 复数类型
	<img src="https://bucket-wl.oss-cn-guangzhou.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-02-08%20173527.png" style="zoom:70%;" />

```python
x=123+456j
print('实数部分：',x.real)
print('虚数部分：',x.imag)
'''
实数部分： 123.0
虚数部分： 456.0
'''
```

#### 2、字符串类型（不可变数据类型）

**定义：**连续的字符数列可以表示计算机所能识别的一切字符

**字符串的界定符：**单引号、双引号、三引号（可以用于定义多行字符串）

> **转义字符：**\n(换行符)、\t(水平制表位)
> ***原字符：**使转义字符失效的字符，r或R*
>
> ```python
> print('北京\n欢迎你')
> print(r'北京\n欢迎你')
> '''
> 北京
> 欢迎你
> 北京\n欢迎你
> '''
> ```

>**索引：**字符串又被称为有序的字符序列，对字符串中某个字符的检索称为索引（正向索引从0到N-1，逆向索引从-1到-N）
><img src="https://bucket-wl.oss-cn-guangzhou.aliyuncs.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-02-08%20180143.png" style="zoom:80%;" />
>
>```python
>s='helloworld'
>print(s[0],s[-10]) # 序号0和序号-10表示的是同一个字符
>print('北京欢迎你'[4]) # 获取字符串中索引为4的字符
>print('北京欢迎你'[-1]) # 获取字符串中索引为-1的字符，和索引为4的字符相同
>```
>
>
>
>**切片：**对字符串中某个子串或区间的检索称为切片
>**切片的语法结构：**==字符串或字符串变量[N:M]==
>
>```python
>s='helloworld'
>print(s[2:7])
>print(s[-4:-9])#结果同上
>#he llowo rld
>#01 23456 789
>```

**常用的字符串操作：**

- x + y （+是连接符）：将字符串x和y连接起来

- x * n 或 n * x ：复制n次字符串x

- x in s ：如果是x的s子串，结果为True，否则结果为False
	```python
	x='北京冬奥会'
	print('北京' in x)
	print('上海' in x)
	'''
	True
	False
	'''
	```

#### 3、布尔类型（不可变数据类型）

**定义：**用来表示”==真==“值和“==假==”值的数据类型
**True**表示整数**1**，**False**表示整数**0**
用bool()来查看对象的布尔值

> **布尔值为False的情况：**
>
> 1. False或者None
> 2. 数值中的0，包括 0 ， 0.0 ，虚数0 
> 3. 空序列，包括空字符串，空元组，空列表，空字典，空集合
> 4. 自定义对象的实例，该对象的bool()方式返回False或len()方式返回0

#### 4、类型转换函数

1. 隐式转换

```python
a=True
print(a+10)
#11
```

2. 显式转换

	<img src="https://bucket-wl.oss-cn-guangzhou.aliyuncs.com/image-20250219180448323.png" alt="image-20250219180448323" style="zoom:90%;" align="left" />

	```python
	#float转换成int类型只保留整数部分，不进行四舍五入
	print(int(3.14))
	print(int(3.9))
	'''
	3
	3
	'''
	```

#### 5、eval函数（类型转换函数）

用于去掉字符串最外侧的引号，并按照Python语句方式执行去掉引号后的字符串
经常和input()函数一起使用

> `age=eval(input('年龄：'))`
>
> ```python
> hello='你好'
> print(hello)
> print(eval('hello'))
> '''
> 你好
> 你好
> '''
> ```

#### 6、运算符

1. 算数运算符
    注意区分（**//**）是整除，（**/**）是除，结果是浮点数与C语言不同
    （******）是幂运算
2. 赋值运算符
    Python支持系列解包赋值
    `a,b=10,20`同时给a和b赋值
    **也可以用此方法交换两个变量的值**
    **`a,b=b,a`**
3. 比较运算符
4. 逻辑运算符
	是对真和假两个布尔值的再运算结果任然是一个布尔值
	- and
		只要有一个结果为False，即为False
	- or
		只要有一个结果为True，即为True
	- not
		与上俩个从左到右不一样，这个是==从右到左==的，对表达式整体取反

#### 7、位运算符

把数据看成二进制数来进行运算

1. **按“==位与==”运算（==&==）：**只有1和1输出结果为1否则为0
2. **按“==位或==”运算（==|==）：**两个数都为0时结果为0，只要有一个是1结果为1
3. **按“==位异或==”运算（==^==）：**两个数相同结果为0否则结果为1
4. **按“==位取反==”运算（~）：**不同于上面三个有两个操作数，这个只有一个操作数，直接取反
5. **==左移位==（<<）：**将一个二进制数向左位移指定位数，左边溢出的位数被丢弃，右边的空位用0补充
	*例：`3<<2`得8，即为3\*2\*2*
6. **==右移位==（>>）：**将一个二进制数向右位移指定位数，右边溢出的位数被丢弃，**若最高位是0（正数），左边空位用0补充，若最高位是1（负数），左边空位用1补充**
	*例：`16>>2`得 4 ，即为16//2//2———`-8>>2`得 -2 ，即为-8//2//2*

**注意各运算符的优先级**

![](https://bucket-wl.oss-cn-guangzhou.aliyuncs.com/image-20250219235514195.png)

## 第四章、程序的流程控制

### 一、程序的描述方式及组织架构

#### 1、程序的描述方式

1. 自然语言
	用人类语言直接描述程序，可以用IPO模式
2. 流程图
	用一系列的图形、流程线和文字说明描述程序的基本操作和控制流程，主要适用于较短的算法
	**描述流程图的图像：**
	- 起止框（圆角矩形）
	- 判断框（菱形）
	- 处理框（长方形）
	- 输入输出框（平行四边形）
	- 注释框（大括号）
	- 流向线（箭头）
	- 连接点（园）
3. 伪代码
	是介于自然语言和编程语言之间的一种算法描述语言，如果程序比较小可以之间使用代码描述

#### 2、程序的组织结构

- 顺序结构（最基本）
	按照程序语句的自然顺序，从上到下，依次执行每条语句

- 选择结构/分支结构
	按照条件选择执行不同的代码段

	- 单分支选择结构 **if**

	- 双分支选择结构 **if-else**

		> 简化
		> `result='恭喜你中奖了' if number==1234 else '你未中奖'`

	- 多分支选择结构 **if-elif-elif-else……**
		else不是必须的，可以没有else

	- match-case模式匹配，Python3.11新特性
		```python
		score=input('请输入你的等级')
		match score:
			case 'A':
		    print('优秀')
		  case 'B':
		    print('良好')
			case 'C':
		    print('一般')
		```

	
	```python
	if a>0:
	  a++
	```
	
	- 注意：
	
		- **if后面的冒号和与下一行的缩进非常重要**
			如果语句块只有一句代码，可以将语句块直接写在if的：后面
		- 通过比较运算符计算出来的，判断结果为布尔值类型
		- 单分支、双分支、多分支结构可以**互相嵌套**使用
	
		- 可以用and（都要满足）、or（只要满足其中一个）连接多个判断条件
	
- 循环结构

	- ==**for**== 遍历循环
		<img src="https://bucket-wl.oss-cn-guangzhou.aliyuncs.com/image-20250301230246901.png" alt="image-20250301230246901" style="zoom:80%;" />

		语法结构：

		```python
		for 循环变量 in 遍历对象:
		  语句块
		```

		range(stop)
		range(start,stop)[n,m)(包含n不含m)
		range(start,stop,step)

		**for 循环的特殊模式 **
		for——else循环
		当循环正常结束执行else，不正常结束(遇到break),不执行else
		
	- ==**while**==无限循环
	
		*注：在Python中循环体没有语句块会报错，使用pass起到占位符的作用*

## 第五章、组合数据类型

序列：字符串、列表（有序序列）、元组（有序序列）、集合（无序序列）、字典（无序序列）

### 一、序列和索引

切片语法结构：序列[start(包含)​\:end(不包含):step]

常用操作：

1. index()查第一次出现的索引位置
2. count()计数
3. in *and* not in

### 二、列表

列表是可变类型

> **列表的修改**
> lst.append(x)在末尾添加一个元素x
> lst.extend([])使用一个列表去扩充lst,可以添加多个元素
> lst.insert(index,x)在指定位置(index)添加一个元素x
> lst.remove(x)把列表中出现的第一个x删除
> lst.pop()弹出一个元素并删除
> lst.clear()清除列表中所有元素
> lst.reverse(x)将列表中的元素反转
> lst.copy()拷贝列表中的元素生成一个新的列表

> **列表的排序**
> lst.sort()默认升序lst.sort(reverse=Ture)(降序)
> sorted()也可以用系统内置函数（赋给一个新的列表，原列表不变）
> 字母按先大后小
> 也可以用lst.sort(key=str.lower)进行无大小写排序

> **列表的生成式**
> lst=[expression **for** item **in** range]
> lst=[expression **for** item **in** range **if** condition]\(可以添加判断，选择列表中的元素)

### 三、元组

不可变数据类型

使用()定义元组，元素与元素之间用英文的逗号进行分隔，只有一个元素，逗号也不能省略

> **创建方法**
> 之间创建
> 使用内置函数tuple()（只能是一个列表或字符串，会拆分成多个元素或字符）

==元组不可改，但是通用的count(),index(),in /not in 也可以用==

### 四、字典

**字典类型是根据一个信息去查找另一个信息，构成了“==键值对==”**
**可变数据类型**

字典的键不能重复且只能是不可变数据类型
当键相同时不会报错，而是后者对前者的value值进行了覆盖

> **字典的创建方式**
>
> 使用花括号直接创建
> `d={key1:value1,key2:value2...}`
>
> 使用内置函数dict()
> 1：dict(key1=value1,key2=value2….)
> 2:   zip(lst1,lst2)(lst1作为键与lst2的值一一对映)（映射的结果是zip对象，需要用dict()转换）

字典的取值

1. d[key]
	如果键不存在会报错

2. d.get(key)
	如果键不存在，可以指定默认值

	```python
	d={10:'hello',11:'world',12:'python'}
	print(d.get(13))
	# None
	print(d.get(13),'木有')
	# 木有
	```

字典的遍历

```python
d={10:'hello',11:'world',12:'love'}
for itme in d.items():
    print(itme)
# 分别输出
for key,value in d.items():
    print(key,'---->',value)
```

> 字典操作的相关方法
> d.values()获取所有value（得到对象）
> d.keys()获取所有key（得到对象）
> d.pop(key,default)key存在获取对应value，同时删除key-value对，否则获取默认值
> d.popitme()随机获取一个key-value对，结果为元组类型，然后删除
> d.clear()清空
> 直接用赋值的方式向字典添加元素`d[13]='李华'`

> **字典的生成式**
> d={ **key:value **for item in range()}
> d={**key:value** for item in **zip(lst1,lst2)**}

### 五、集合

**无序不重复的序列，只能存不可变数据类型（不能存字典和列表）**

**可变数据类型**

> **创建方式**
> 1：直接用{}创建   s={element1,element2,….elementN}
>
> 2：使用内置函数set()   s=set(可迭代对象)

> **操作符**
> **&**交集
> **|**并集
> **-**差集
> **^**补集

> **操作方法**
> s.add(x)如果x不在集合s中，则添加进去
> s.remove(x)如果x在集合中，将他删除，如果不在集合当中，程序报错
> s.clear()清除
>
> 遍历可以用enumerate()

### 六、python3.11新特性

结构模式匹配

字典合并

同步迭代

## 第六章、字符串及正则表达式

不可变数据类型

### 一、字符串的常用操作

> str.lower()全部转为大写
> str.upper()全部转为小写
> str.split(sep=None)按照指定的分隔符sep进行分隔，结果为列表类型
> str.count(sub)统计sub这个字符串在str出现的次数
> str.find(sub)sub在str中是否存在，不存在结果为-1，存在结果为sub首次出现的索引
> str.index(sub)与find()相同，区别在如果不存在，程序报错
> str.startwith(s)查询字符串str是否以子串s开头
> str.endwith(s)查询字符串str是否以子串s结尾
> str.replace(old,news)用news替换字符串s中所有old字符串，可以在后面添加替换的次数
> str.center(width,fillchar)在指定的宽度范围内居中，可以使用fillchar进行填充
> str.join(iter)在iter中每个元素的中间增加一个新的字符串str
> str.strip(chars)从字符串中去掉左侧和右侧chars中列出的字符串
> str.lstrip(chars)从字符串中去掉左侧chars中列出的字符串
> str.rstrip(chars)从字符串中去掉右侧chars中列出的字符串

### 二、格式话字符串

1. 占位符
2. f-string
3. str.format()
	```python
	s = 'hello world'
	print('{0:-^20}'.format(s))  # 居中,-填充符
	print('{0:*<20}'.format(s))  # 左对齐，*填充符
	print('{0:*>20}'.format(s))  # 右对齐，*填充符
	print('{0:,}'.format(987654321))  # 三位一逗
	print('{0:.2f}'.format(123.4567))  # 小数精度
	print('{0:.5}'.format(s))  # 最大显示长度
	```

	{0：b(二进制)、o(八进制)、x(十六进制)}

### 三、字符串的编码和解码

> **编码：encode()**  (str–>bytes)
> str.encode(encoding=‘utf-8’ , errors= ‘strict/ignore/replace’ )
>
> **解码：decode()**  (bytes–>str)
> str.decode(encoding=‘utf-8’ , errors= ‘strict/ignore/replace’ )

### 四、数据的验证

> str.isdigit()所有的字符都是数字（阿拉伯数字）
> str.isnumeric()所有的字符都是数字（所有数字罗马数字，中文数字）
> str.isalpha()所有的字符都是字母（包含中文字符）
> str.isalnum()所有的字符都是数字或者字母（包括中文字符）
> str.islower()所有的字符都是小写
> str.isupper()所有的字符都是大写
> str.istitle()所有的字符都是首字母大写
> str.isspace()所有的字符都是空白字符

### 五、字符串的处理

#### 1、字符串的拼接操作

1. 使用**str.join()**进行拼接
	`print('连接的字符（可以为空字符）'.join([s1,s2]))`
2. 直接拼接
3. 使用格式化字符串进行拼接

#### 2、字符串的去重

- 遍历

- 集合去重
	```python
	s='helllllo worldddd'
	new_s=set(s)
	lst=list(new_s)
	lst.sort(key=s.index)  # 按照元字符串序列进行排序
	print(''.join(lst))
	```

### 六、正则表达式

特殊的字符串

- **元字符：具有特殊意义的专用字符**,例如：“^”和“$”分别表示匹配的开始和结束

> **.**   匹配任意字符除了\n
> \w  匹配字母、数字、下划线
> \W 匹配非字母、数字、下划线
> \s  匹配任意空白字符
> \S  匹配任意非空白字符
> \d  匹配任意十进制数

- **限定符：用于限定匹配的次数**

> ？ 匹配前面的字符0或1次
> \+   匹配前面的字符1次或多次
> \*   匹配前面的字符0次或多次
> {n}  匹配前面字符n次
> {n,}  匹配前面字符最少n次
> {n,m}  匹配前面字符最少n次，最多m次

- 区间字符（ **[]** ）：匹配[]中所指定的字符

- 排除字符（ **^** ）：匹配不在[]中的字符
- 选择字符（ **|** ）：用于匹配|左右任意字符
- 转义字符（ **\\** ）
- **[\\u4e00-\\u9fa5]**：匹配任意汉字
- **分组()**：改变限定符的作用

==**re模块：用于实现python正则表达式（python内置模块）**==

> **re.match(pattern,string,flags=0)：用于从字符串开始位置进行匹配，如果起始位置匹配成功，结果为Match对象，否则结果为None**
> **re.search(pattern,string,flags=0)：用于在整个字符串中搜索第一个匹配值，如果匹配成功，结果为Match对象，否则结果为None**
> **re.findall(pattern,string,flags=0)：用于在整个字符串所有符合正则表达式的值，结果是一个列表**
> **re.sub(pattern,repl,string,count,flags=0)：用于实现对字符串内指定子串的替换**
> **re.split(pattern,string,maxsplit,flags=0))：与字符串中split（）方法功能相同**

## **第七章、异常处理**

### 一、bug

1. 粗心导致的语法错误
2. 知识点不熟练导致的错误
3. 思路不清晰导致的问题
4. 用户输入导致的程序崩溃

### 二、Python异常处理机制

**语法结构：**

> ```python
> try:
>   可能会抛出异常代码
> except:
>   异常处理代码（报错后执行的代码）
> ```
>
> 

> ```python
> try:
>   可能会抛出异常代码
> except 异常类型A:
>   异常处理代码（报错后执行的代码）
> except 异常类型B:
>   异常处理代码（报错后执行的代码）
> ```
>
> except可以写多个，最大的异常类型（BaseException）写在最后一个可以捕获最多的异常类型

> ```python
> try:
>   可能会抛出异常代码
> except:
>   异常处理代码（报错后执行的代码）
> else:
>   没有抛异常要执行的代码
> ```

> ```python
> try:
>   可能会抛出异常代码
> except:
>   异常处理代码（报错后执行的代码）
> else:
>   没有抛异常要执行的代码
> finally:
>   无论是否产生异常都执行的代码
> ```

>  **raise：抛出一个异常，从而提醒程序出现了异常情况，程序能够正确的处理这些异常情况**
>
> 语法结构：
> `raise[Exception类型（异常描述信息）]`

### 三、Python常见的异常类型

1. ZeroDivisionError：除数为0
2. IndexError：索引超出范围
3. KeyError：字典取值时key不存在
4. NameError：使用一个没有声明的变量时引发的错误
5. SyntaxError：Python中的语法错误
6. ValueError：传入值错误
7. AttributeError：属性或方法不存在的异常
8. TypeError：类型不合适引发的异常
9. IndentationError：不正确缩进引发的异常

## 第八章、函数及常用的内置函数

定义：是将一段实现功能的完整代码，使用函数名进行封装，通过函数名称进行调用，达到一次输入多次输出的结果

**用关键字def来定义函数**

```
def 函数名称（参数列表）:
	函数体
	[return返回值列表]（非必须）
```

### 一、参数的传递

- 位置参数
	调用时的参数个数和顺序必须与定义的参数个数和顺序相同

- 关键字参数
	在函数调用时，使用“形参名称=值”的方法进行传参，传递参数的顺序可以和定义时参数的顺序不同

- 默认值参数
	在函数定义时，直接对形式参数进行赋值，在调用时如果该参数不传值，将使用默认值，如果传值，则使用传递的值

- 可变参数

	- 个数可变的位置参数
		在参数前加一颗星（*para），para是形式参数的名称，函数在调用时可以接受任意个数的实际参数，并放到一个元组中

		> 可以传一个列表（元组、集合），当做一个元素
		> 或者在传参时在列表前加一个星(*)对列表（元组、集合）进行系列解包，把列表中每个元素单独传入函数

	- 个数可变的关键字参数
		在参数前加两颗星（\**para），函数在调用时可以接收任意多个“参数=值”，并放到一个字典中

		> 字典不能直接传入，但是也可以用\**进行解包

*注：如果在传参中既有位置传参也有关键字传参，位置传参在前，关键字传参在后，不然会有语法错误*
	*在定义函数形参时，也要遵循位置参数在先，关键词参数在后*

### 二、函数的返回值

- 可有可无
- 可以是一个值、或多个值，如果返回值的多个值，结果是一个元组类型
	`a,b,c=get_sum(10)`把三个返回值解包赋值给a,b,c
- 可以出现在函数的任意位置，用于结束函数

### 三、变量的作用域

- 局部变量

	> 定义：
	> 在函数定义处的参数和函数内部定义的变量
	>
	> 作用范围：
	> 仅在函数内部，函数执行结束，局部变量的生命周期也结束

- 全局变量

	> 定义：
	> 在函数外定义的变量，或在函数内部使用==global==关键字（声明和赋值分开执行）修饰的变量
	>
	> 作用范围：
	> 整个程序，程序运行结束，全局变量的生命周期才结束

当全局变量和局部变量名字相同时局部变量的优先级高

### 四、匿名函数lambda

定义：是指没有名字的，只能使用一次，一般是在函数体只有一句代码且只有一个返回值的时候可以用匿名代码来简化

**语法机构：**
**`result = lambda 参数列表：表达式`**

**使用**：

```python
s = lambda a,b:a+b
print(s(10,20))
```

### 五、递归函数

- 在一个函数体的内部去调用该函数体的本身

- 完整的递归操作：

	1. 递归调用
	2. 递归终止条件

	一般使用if-else结构来判断递归的调用和递归

**斐波那契数列**：f(n)=f(n-1)+f(n-2)

### 六、常用的内置函数

不需要使用前缀就可以直接调用的函数

- 数据类型转换函数：
	bool()、str()、int()、float()、list()、tuple()、set()、dict()

- 数学函数：

	> abs()：取x的绝对值
	> divmod()：取x与y的商和余数
	> max(sequence)：获取最大值
	> min(sequence)：获取最小值
	> sum(iter)：对可迭代对象进行求和
	> pow(x,y)：获取x的y次幂
	> round(x,d)：对x进行保留d位小数，结果四舍五入，d可以是负数，结果保留十位、百位、千位

- 迭代器操作函数：

	> sorted(iter)：对可迭代对象进行排序
	> reversed(sequence)：翻转序列生成新的迭代器对象
	> zip(iter1,iter2)：将iter1和lter2打包成元组并返回一个可迭代的zip对象
	> enumerate(iter)：根据iter对象，前面加上序号创建一个enumerate对象
	> all(iter)：判断可迭代对象iter中所有元素的布尔值是否都为True，如果都为True，结果为True
	> any(iter)：判断可迭代对象iter中所有元素的布尔值是否都为False，如果都为False，结果为False
	> next(iter)：获取迭代器的下一个元素
	> filter(function,iter)：通过指定条件过滤序列并返回一个迭代器对象
	> map(function,iter)：通过函数function对可迭代对象iter的操作返回一个迭代器对象

	注：返回为对象都无法直接查看，可以用list()把他转为一个列表，再查看

- 其他函数：

	> format(value,format_spec)：将value以format_spec格式进行输出（数值型默认右对齐，字符串默认左对齐）（可以修改）`format('hello','->30')`（-是填充符，>是右对齐，30是宽度）
	> len(s)：计算s长度或s元素个数
	> id()：获取对象的内存地址
	> type(x)：获取x的数据类型
	> eval(s)：执行s这个字符串所表示的Python代码（取引号）

## 第九章、面向对象程序设计

### 一、两大编程思想

- **面向对象**
  **功能上的封装**
  事情比较简单，可以用线性思维去解决
  封装/继承/多态（三大技术）
- **面向过程**
  **属性和行为上的封装**
  事物比较复杂，使用简单的线性思维无法解决
  函数

**共同点：**都是去解决问题的一种思维方式，二者是相辅相成，不是独立的
解决复杂问题，通过面向对象方式方便我们从宏观上把握事物之间复杂的关系，方便我们分析整个系统，具体到微观操作，仍然使用面向过程方式来处理

### 二、类和对象

**在面向对象编程中两大非常重要的概念**

**类：是有n多个对象抽取出==“像”==的==属性==和==行为==从而归纳总结出来的一种==类别==**
是泛指的指代多个，是由对象抽象来的

在Python中一切皆对象

> **自定义数据类型的语法结构为：**
> `class 类名():`(类名要求首字母大写,小括号可写可省略)
>
> **创建对象的语法格式：**
> `对象名=类名()`

**类是模板，对象是具体的实例**

```python
class Student():
  pass
stu=Student()
print(type(stu))
# <class '__main__.Student'> #类型是Student这个类
```

### 三、类的组成

**构成：**

- 类的名称：类名
- 类的属性：一组数据，一个类的属性有很多，我们只关注需要使用的
- 类的方法：允许对进行操作的方法（行为、函数）

1. 类属性
	直接定义在类中，方法外的**变量**
2. 实例属性
	定义在\_init_方法中，使用self打点的**变量**
3. 实例方法
	定义在类中的函数，而且自带参数self，是类中方法的第一个形参，可以写成其他的名字
4. 静态方法
	使用装饰器@staticmethod修饰的方法，不能调用实例属性也不能调用实例方法
5. 类方法
	使用装饰器@classmethod修饰的方法，不能调用实例属性也不能调用实例方法

在类中调用、操作属性：self.(属性)
在类外调用、操作属性：对象名.属性

### 四、魔法方法

以两个下划线开始和两个下划线结尾，并在满足某个特定的条件下会自动调用，这累方法称为魔法方法

- \__init__：**在创建对象之后会立即调用**
	作用：

	1. 用来给对象添加属性，给对象一个初始值（构造函数）
	2. 代码的业务需求，每创建一个对象都需要执行的代码可以写在\__init__中

	*注：如果在\__init__方法中有self以外的形参，在创建对象的时候要给额外的形参传值（类名(实参)）*

### 五、动态绑定

- 动态绑定属性

	`对象名.要添加的属性=''`

- 动态绑定方法

	```python
	def introduce():
	  print('我是一个普通的函数，我被动态绑定成了stu2的方法')
	stu2.fun=introduce #不要括号，有括号就是调用了，现在是赋值
	```

### 六、面向对象三大基本特征，封装、继承、多态

**面向过程：**

- 函数

**面向对象：**

- **封装**：（保护程序安全）
	隐藏内部细节，对外提供操作方法
	**权限控制：**通过对属性或方法添加单下划线、双下划线、首尾双下划线来实现

	- 单下划线开头：
		表示protected受保护的成员，这类成员被视为只能内部使用，允许类本身和子类进行访问，但实际上它可以被外部代码访问

	- 双下划线开头：
		表示private私有成员，这类成员只允许定义该属性或方法的类本身进行访问

	- 首尾双下划线：
		一般表示特殊方法

		修饰器：`@property`把方法转成属性，来达到private属性可以被访问的目的，这能看不能改
		```python
		@property
		def age(self):
			return self.__age
		#在调用时不需要小括号，直接当属性用
		```

		把属性设置成可写属性
		```python
		@age.setter
		def age(self,value):
		  self.__age=value
		```

		

- **继承**：（代码的重写、复用）

  > **语法结构：**
  > `class 类名(父类1，父类2……父类N)`

  - 继承了父类的公共的和受保护的成员，可以外部直接调用，在子类内可以使用`super().方法`来调用父类的方法
  - 一个子类可以继承多个父类，不能用super了，程序不知道调用哪个父类，用`父类名.方法`来调用（用类名进行区分）
  - 一个父类也可以拥有多个子类
  - 如果继承多个父类之中有同名的方法，默认调用第一个的方法

  > **方法重写：**
  > 当父类的方法不能完全适用于子类的需求是，可以重写父类的方法
  > 在重写父类的方法是名称一定要相同，在子类重写后还需要父类的原来的方法可以用**`super().方法名()`**来调用父类的方法

- **多态**（实现程序的可拓展性）

	- 多种形态，即便不知道一个变量所引用的对象是什么类型，仍然可以通过这个变量调用对象的方法
	- 可以**动态决定**调用哪个对象中的方法
	- 不管对象的数据类型，不管继承关系，只要不同的类有同名的方法，即可实现多态

> 操作一个对象的状态（属性、方法）：
> hasatte(obj,‘x’)：obj有‘x’属性吗
> getattr(obj,’y’)：获取‘y’属性，如果属性不存在会抛出AttributeError的错误，也可以传入一个default参数，如果属性不存在，返回默认值
> setattr(obj,’z’,19)：设置一个z属性为19
> 以上同样使用与获取修改方法

object类：

1. 所有类直接间接的父类

2. 所有类都拥有其属性和方法

	其中特殊的方法：

	> \_\_new\_\_():由系统调用，用于创建对象
	> \_\_init\_\_():创建对象时自动调用，用于初始化对象属性值
	> \_\_str\_\_():用于对象的描述，返回值是str类型，默认输出对象的内存地址，也可以重写输出字符串，在输出对象时**默认调用**的

	> python中的运算符也是调用特殊方法实现的：
	>
	> \_\_add\_\_():+	\_\_sub\_\_():-	\_\_lt\_\_():\<	\_\_le\_\_():\<=	\_\_gt\_\_():\>		\_\_ge\_\_:\>=
	> \_\_eq\_\_():\=\=	\_\_ne\_\_():!=	\_\_mul\_\_():\*	\_\_truediv\_\_():/	\_\_mod\_\_():%	\_\_floordiv\_\_()://
	> \_\_pow\_\_():**

	> 特殊属性：
	>
	> obj.\_\_dict\_\_:对象的属性字典，可以查看对象的实例属性，以字典的形式一一对应输出
	> obj.\_\_class\_\_:对象所属的类
	> class.\_\_bases\_\_:类的父类元组，所有父类以元组的形式输出
	> class.\_\_base\_\_:类的父类，与上面不同的是，如果继承了很多个父类，结果只显示第一个
	> class.\_\_mro\_\_:类的层次关系，先输出自己，然后父类，爷类……
	> 方法：
	> class.\_\_subclasses\_\_():类的子类列表

### 七、类的深拷贝和浅拷贝

- **变量的赋值**
	只是形成两个变量，实际上还是指向**同一个对象**，不开辟新的内存空间，指向的是同一块内存地址

- **浅拷贝：**
	import copy 模块，拷贝时，对象包含的**子对象内容不拷贝**，因此，源对象与拷贝对象会引用同一个子对象，创建对象开辟一块新的内存空间，但是子对象不开辟，还是指向原来的那块内存空间
- **深拷贝：**
	使用copy模块的deepcopy函数，递归拷贝对象中包含的子对象，**源对象和拷贝对象所有的子对象也不相同**，全部重新开辟内存空间，包括子对象

## 第十章、模块

### 一、简介

- 在python中后缀名为.py的python文件就是一个模块
- 在模块中可以定义函数、类
- 模块可以避免函数、类、变量等名称冲突的问题
- 模块提高的代码的可维护性和可重用性
- 在给模块命名时，要求全部使用小写字母，多个单词之间使用下划线分割
- 如果自定义模块名称与系统内置模块名称相同，导入时会优先导入自定义模块

### 二、分类

- 系统内置模块：
	由开发人员编写好的模块，在安装python解释器时，一同安装
- 自定义模块：
	一个以.py结尾的文件就是一个模块，新建python文件实际上就是在新建模块
- 第三方模块

### 三、自定义模块的作用

- 规范代码，将功能相同的函数、类等封装到一个模块中，让代码更易阅读
- 目的与系统内置模块相同时，即可以被其他模块调用，提高开发的效率

### 四、模块的导入

> import导入方式的语法结构：
> import 模块名称 [as 别名]
>
> from…import导入方式的语法结构
> from 模块名称 import 变量/函数/类/*(通配符)(导入所有)
> 这种方式导入后的变量、函数等可以直接调用，不需要打点调用
>
> 注：一次导入多个模块，模块之间使用逗号进行分隔
> 如果两个模块中有重名，后导入的会把前导入的进行覆盖，只能打点调用

### 五、包

- 可以避免模块名称冲突的问题
- 含有\_\_init\_\_.py文件的文件夹
- 可以将功能相似的模块放到一个包中，方便模块的组织和管理

**包中的模块导入：**

1. import 包名.模块名
2. from 包名 import 模块名

注：包的创建后，包下面会自动生成一个\_\_init\_\_.py的文件，导入包时，这个文件中的代码会自动被调用执行，只执行一次

**主程序运行：**
`if __name__== '__main__':`

阻止导入的模块中的全局变量的数据被输出执行

### 六、常用的内置模块

在和python解释器一同被安装进来的模块，叫做系统内置模块，也称标准库、标准模块

> os模块：与操作系统和文件相关操作有关的模块
> re模块：用于python的字符串中执行正则表达式的模块
> random模块：产生随机数
> json模块：用于对高维数据进行编码和解码的模块
> time模块：与时间相关的模块
> datetime模块：与日期时间相关的模块，可以方便的显示日期并对日期进行运算

<img src="https://bucket-wl.oss-cn-guangzhou.aliyuncs.com/image-20250318232725443.png" alt="image-20250318232725443" style="zoom:80%;" />



<img src="https://bucket-wl.oss-cn-guangzhou.aliyuncs.com/image-20250318232643374.png" alt="image-20250318232643374" style="zoom:80%;" />



![image-20250318232828101](https://bucket-wl.oss-cn-guangzhou.aliyuncs.com/image-20250318232828101.png)
